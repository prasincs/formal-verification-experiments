//! # Bitmap Font
//!
//! Simple 8x8 bitmap font for text rendering.

use crate::framebuffer::Framebuffer;
use crate::graphics::Color;

/// 8x8 bitmap font (ASCII 32-95: space to underscore)
/// Each character is 8 bytes, one per row, MSB is leftmost pixel
/// 64 characters Ã— 8 bytes = 512 bytes
pub static FONT_8X8: [u8; 512] = [
    // Space (32)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ! (33)
    0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
    // " (34)
    0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
    // # (35)
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
    // $ (36)
    0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00,
    // % (37)
    0x00, 0x66, 0xAC, 0xD8, 0x36, 0x6A, 0xCC, 0x00,
    // & (38)
    0x38, 0x6C, 0x68, 0x76, 0xDC, 0xCC, 0x76, 0x00,
    // ' (39)
    0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ( (40)
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,
    // ) (41)
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,
    // * (42)
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
    // + (43)
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
    // , (44)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
    // - (45)
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // . (46)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
    // / (47)
    0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
    // 0 (48)
    0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00,
    // 1 (49)
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // 2 (50)
    0x7C, 0xC6, 0x0C, 0x18, 0x30, 0x66, 0xFE, 0x00,
    // 3 (51)
    0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00,
    // 4 (52)
    0x0C, 0x1C, 0x3C, 0x6C, 0xFE, 0x0C, 0x0C, 0x00,
    // 5 (53)
    0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00,
    // 6 (54)
    0x7C, 0xC6, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00,
    // 7 (55)
    0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
    // 8 (56)
    0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00,
    // 9 (57)
    0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0xC6, 0x7C, 0x00,
    // : (58)
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
    // ; (59)
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
    // < (60)
    0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00,
    // = (61)
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
    // > (62)
    0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00,
    // ? (63)
    0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
    // @ (64)
    0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00,
    // A (65)
    0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
    // B (66)
    0xFC, 0xC6, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC, 0x00,
    // C (67)
    0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00,
    // D (68)
    0xF8, 0xCC, 0xC6, 0xC6, 0xC6, 0xCC, 0xF8, 0x00,
    // E (69)
    0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xFE, 0x00,
    // F (70)
    0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xC0, 0x00,
    // G (71)
    0x7C, 0xC6, 0xC0, 0xCE, 0xC6, 0xC6, 0x7C, 0x00,
    // H (72)
    0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00,
    // I (73)
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // J (74)
    0x06, 0x06, 0x06, 0x06, 0xC6, 0xC6, 0x7C, 0x00,
    // K (75)
    0xC6, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0xC6, 0x00,
    // L (76)
    0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0x00,
    // M (77)
    0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00,
    // N (78)
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
    // O (79)
    0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // P (80)
    0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0xC0, 0x00,
    // Q (81)
    0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06,
    // R (82)
    0xFC, 0xC6, 0xC6, 0xFC, 0xD8, 0xCC, 0xC6, 0x00,
    // S (83)
    0x7C, 0xC6, 0xC0, 0x7C, 0x06, 0xC6, 0x7C, 0x00,
    // T (84)
    0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
    // U (85)
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // V (86)
    0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00,
    // W (87)
    0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00,
    // X (88)
    0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
    // Y (89)
    0xC3, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x00,
    // Z (90)
    0xFE, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xFE, 0x00,
    // [ (91)
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,
    // \ (92)
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
    // ] (93)
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,
    // ^ (94)
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // _ (95)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
];

/// Font dimensions
pub const CHAR_WIDTH: u32 = 8;
pub const CHAR_HEIGHT: u32 = 8;

/// Get the 8-byte bitmap for a character
/// Returns array of 8 bytes, one per row, MSB is leftmost pixel
pub fn get_char_bitmap(c: u8) -> [u8; 8] {
    let ascii = c as usize;

    // Only support ASCII 32-95 (space to underscore) and some extras
    // Map lowercase to uppercase for simplicity
    let mapped = if ascii >= 97 && ascii <= 122 {
        ascii - 32  // lowercase to uppercase
    } else if ascii >= 32 && ascii <= 95 {
        ascii
    } else {
        32  // default to space
    };

    let index = (mapped - 32) * 8;
    let mut result = [0u8; 8];
    for i in 0..8 {
        result[i] = FONT_8X8[index + i];
    }
    result
}

/// Draw a single character
pub fn draw_char(fb: &mut Framebuffer, x: u32, y: u32, c: char, color: Color) {
    let ascii = c as u32;

    // Only support ASCII 32-95 (space to underscore)
    if ascii < 32 || ascii > 95 {
        return;
    }

    let index = ((ascii - 32) * 8) as usize;

    for row in 0..8u32 {
        let byte = FONT_8X8[index + row as usize];
        for col in 0..8u32 {
            if (byte >> (7 - col)) & 1 != 0 {
                fb.put_pixel(x + col, y + row, color);
            }
        }
    }
}

/// Draw a string
pub fn draw_string(fb: &mut Framebuffer, x: u32, y: u32, s: &str, color: Color) {
    let mut cursor_x = x;

    for c in s.chars() {
        if c == '\n' {
            continue; // Skip newlines for now
        }

        draw_char(fb, cursor_x, y, c, color);
        cursor_x += CHAR_WIDTH;

        // Stop if we go off screen
        let (width, _) = fb.dimensions();
        if cursor_x >= width {
            break;
        }
    }
}

/// Draw a string with scaling (2x, 3x, etc.)
pub fn draw_string_scaled(
    fb: &mut Framebuffer,
    x: u32,
    y: u32,
    s: &str,
    color: Color,
    scale: u32,
) {
    let mut cursor_x = x;

    for c in s.chars() {
        if c == '\n' {
            continue;
        }

        draw_char_scaled(fb, cursor_x, y, c, color, scale);
        cursor_x += CHAR_WIDTH * scale;

        let (width, _) = fb.dimensions();
        if cursor_x >= width {
            break;
        }
    }
}

/// Draw a scaled character
pub fn draw_char_scaled(
    fb: &mut Framebuffer,
    x: u32,
    y: u32,
    c: char,
    color: Color,
    scale: u32,
) {
    let ascii = c as u32;

    if ascii < 32 || ascii > 95 {
        return;
    }

    let index = ((ascii - 32) * 8) as usize;

    for row in 0..8u32 {
        let byte = FONT_8X8[index + row as usize];
        for col in 0..8u32 {
            if (byte >> (7 - col)) & 1 != 0 {
                // Draw a scale x scale block
                fb.fill_rect(
                    x + col * scale,
                    y + row * scale,
                    scale,
                    scale,
                    color,
                );
            }
        }
    }
}
